#!/usr/bin/env python


from __future__ import print_function


import math
from netCDF4 import Dataset as nc
import numpy as np
import matplotlib.pylab as mpl
import matplotlib.colors as colors
import re
import flo_utils as fu

from argparse import ArgumentParser
# import json
# import os
# import shlex
# import shutil
# import subprocess
import sys
from mpl_toolkits.basemap import Basemap, addcyclic, shiftgrid

try:
  import seaborn as sns
  seaborn = True
except ImportError:
  seaborn = False


try:
  import colormaps as cmaps
  mpl.register_cmap(name='viridis', cmap=cmaps.viridis)
  mpl.set_cmap(cmaps.viridis)
  mpl.register_cmap(name='viridis_r', cmap=cmaps.viridis_r)
  mpl.register_cmap(name='plasma', cmap=cmaps.plasma)
  mpl.register_cmap(name='plasma_r', cmap=cmaps.plasma_r)
  mpl.register_cmap(name='magma', cmap=cmaps.magma)
  mpl.register_cmap(name='magma_r', cmap=cmaps.magma_r)
  mpl.register_cmap(name='inferno', cmap=cmaps.inferno)
  mpl.register_cmap(name='inferno_r', cmap=cmaps.inferno_r)
  print ("Got viridis")
  mpl.register_cmap(name='rignot', cmap=cmaps.rignot)
  mpl.register_cmap(name='rignot_r', cmap=cmaps.rignot_r)
except ImportError:
  print ("Viridis not found")

def fix_meridians(mm):
    for mmm in mm.itervalues():
        for mmmm in mmm[1]:
            mmmm.set_text('-') # u'\u23D0')
            mmmm.set_fontsize(5)
            mmmm.set_rotation(90)

def fix_parallels(pp):
          for ppp in pp.itervalues():
            for pppp in ppp[1]:
                pppp.set_text('-') # u'\u23AF')
                pppp.set_fontsize(5)

def fix_attrs(vars,labels):
  for n,x in enumerate(labels):
    if x in vars.keys():
      if "long_name" in vars[x].ncattrs():
        labels[n] = vars[x].long_name
  return labels

def read_var(var, filename, level, options):
  maps= (options.MOLL, options.CYL, options.HAMMER, options.GL, options.ANT, options.NATL, options.diss_proj, options.PISM, options.mapit)
  global_maps = (options.MOLL, options.CYL, options.HAMMER)

  print ("reading %s from %s"%(var, filename), file=sys.stderr)
  try:
    f = nc(filename)
  except IOError:
    fu.cerr("Error opening %s"%filename)
    sys.exit(666)
  vars = f.variables
  var = vars[var]
  if type(var[:]) is np.ma.masked_array:
    data = np.ma.masked_array(np.squeeze(var),np.squeeze(var[:].mask))
  else :
    data = np.squeeze(var)
  if options.missval is not None:
    data = np.ma.masked_values(data, options.missval)
  dims = var.dimensions
  sizes = var.shape
  if level is not None:
    print ("SELECTING LEVEL %d"%level, file=sys.stderr)
    if len(data.shape) == 3:
      data=data[level]
      dims=dims[1:]
    elif len(data.shape):
      data=data[:,level]
      dims=[dims[0]]+[ x for x in dims[2:]]
    else:
      print("I am confused, you asked for level %d, but data is %d-dimensional"%(level, len(sizes)), file=sys.stderr)
      sys.exit(666)
  attrs = { k:  var.getncattr(k) for k in var.ncattrs()}
  dimensions = [vars.get(x,np.arange(sizes[n])) for n,x in enumerate(dims) if sizes[n] > 1 ]
  pcm_dimensions = dimensions[:]
  offset=-1
  labels = [""] * len (dims)
  for n,x in enumerate (dims):
    if sizes[n] > 1:
      offset += 1
      labels[offset] = dims[n]
      if not x  in vars.keys():
        print ("Trying to substitute %s"%(x))
        if ("lat" in vars.keys() and "lon" in vars.keys() and (vars["lat"].size > 1 or vars ["lon"].size > 1)):
          if len(np.squeeze(vars["lat"]).shape) > 1:
            break
          print ("Found coordinate variables")
          la = np.squeeze(vars["lat"])
          lo = np.squeeze(vars["lon"])
          if la.shape == lo.shape == (sizes[n],):
            print ("Sizes match")
            lad = la[-1]-la[0]
            lod = lo[-1]-lo[0]
            if ((not options.lon) and (abs(lad) > abs (lod) or options.lat)):
              dimensions[offset]=la
              labels[offset] = "lat"
            else:
              if (options.rotlon):
                lo [lo>180] = lo[lo>180]-360
              dimensions[offset]=lo
              labels[offset] = "lon"
  if ("lat" in vars.keys() and "lon" in vars.keys() and (len(np.squeeze(vars["lat"]).shape) > 1 or any(maps) )):
    print ("Using map and projection")
    labels[0] = ""
    labels[1] = ""
    dimensions = dimensions +[ vars["lat"], vars["lon"] ]
    if (any(global_maps) and len(dimensions[-1].shape) < 2):
      print ("CONSIDERING LON AS 1d")
      lon = dimensions[-1][:]
      (data, lon) = shiftgrid(180,data,lon)
#      (data, lon) = addcyclic(data, lon)
      lon=lon-360
      dimensions[-1] = lon
    pcm_dimensions = dimensions[:]
    if options.EN or options.EG:
      lat = pcm_dimensions[-2]
      pcm_dimensions[-2] = np.array([90]+(.5*(lat[1:]+lat[:-1])).tolist()+[-90])
      lon = pcm_dimensions[-1]
      dl = lon[1]-lon[0]
      lon2 = np.arange(lon[0]-dl/2., lon[-1]+dl*1.4, dl)
      pcm_dimensions[-1] = lon2
    if "bounds" in vars["lon"].ncattrs() and vars["lon"].getncattr("bounds") in vars.keys():
      newshape = [ x + 1 for x in pcm_dimensions[-1].shape]
      lon = np.zeros(newshape, dtype=pcm_dimensions[-1].dtype)
      lb = vars[vars["lon"].getncattr("bounds")]
      lon[0:-1,0:-1] = lb[:,:,0]
      lon[-1,0:-1] = lb[-1,:,1]
      lon[0:-1,-1] = lb[:,-1,3]
      lon[-1,-1] = lb[-1,-1,2]
      pcm_dimensions[-1] = lon
      lat = np.zeros(newshape, dtype=pcm_dimensions[-1].dtype)
      lb = vars[vars["lat"].getncattr("bounds")]
      lat[0:-1,0:-1] = lb[:,:,0]
      lat[-1,0:-1] = lb[-1,:,1]
      lat[0:-1,-1] = lb[:,-1,3]
      lat[-1,-1] = lb[-1,-1,2]
      pcm_dimensions[-2] = lat

  else:
    if options.transpose: # python has a very strange understanding of order -- we'll fix that
      dimensions[-2:]=dimensions[-1:-3:-1]
      print (dimensions[-2][:])
      print (dimensions[-1][:])
      labels=labels[::-1]
    else:
      if (len(data.shape) == 3):
        data = data.transpose(0,2,1)
      else:
        data=data.transpose()
      print (dimensions[-2][:])
      print (dimensions[-1][:])

    labels = fix_attrs(vars, labels)

  return (data, attrs, dimensions, pcm_dimensions, labels)


def sort_levels (levels = None, minmax=None):
#   levels = levels[0] if levels else None
  if not levels is None:
    levels = np.array([float(x) for x in levels.split(',')])
#    levels = [data.min()] + levels + [data.max()]
    if (len(levels) == 1 ):
      levels = int(levels[0])
      if not minmax is None:
        vrange = minmax[1]-minmax[0]
        step = vrange/(levels-1.)
        levels=np.arange(minmax[0], minmax[1]+step, step)
  else:
    levels = None
  return levels

def contour_var(var, filename, options):
  # Get the data
  (data, attrs, dimensions, pcm_dimensions, labels) = read_var(var, filename, options.level, options)
  # Get the data
  if not options.sub is None :
    (sub_data, sub_attrs, sub_dimensions, sub_pcm_dimensions, sub_labels) = read_var(var, options.sub, options.level, options)
    data = data - sub_data
  maps= (options.MOLL, options.CYL, options.HAMMER, options.GL, options.ANT, options.NATL, options.diss_proj, options.PISM, options.mapit)
  global_maps = (options.MOLL, options.CYL, options.HAMMER)
  # COLORMAP
  cmap = None
#  cmap = sns.color_palette(options.cmap, options.levels if options.levels and len(options.levels.split(",")) == 1 else 7, as_cmap=True)
  try:
    if (options.cmap):
      cmap=options.cmap
    else:
      cmap = sns.cubehelix_palette(as_cmap=True, start=.5)
  except:
    print ("Trouble using colorbar %s."%(options.cmap), file=sys.stderr)

  # LEVELS
  levels = sort_levels(options.levels, options.minmax)
  norm = None
  if not levels is None:
    if type (levels ) is not int : # len(levels) > 1:
      norm = colors.BoundaryNorm(boundaries=levels, ncolors=256)

  # map and projection stuff
  if (len(dimensions) >= 4 or any(maps))  : # 2d coordinates
    print ("using 2d coordinates")
    # map = Basemap(width=8000000,height=8500000,
    #                  resolution='l',projection='stere',\
    #                  lat_ts=70,lat_0=72,lon_0=-45.)
    if not (options.ll is None or options.ur is None or options.MOLL or options.CYL):
      llcrnrlon = options.ll[1]
      urcrnrlon = options.ur[1]
      llcrnrlat = options.ll[0]
      urcrnrlat = options.ur[0]
    elif (not (options.NATL or options.MOLL or options.CYL)):
      llcrnrlon = dimensions[-1][0,0]
      urcrnrlon = dimensions[-1][-1,-1]
      llcrnrlat = dimensions[-2][0,0]
      urcrnrlat = dimensions[-2][-1,-1]
  slices = False
  if (len(data.shape) == 3):
    slices = True
    slicecount = len(data)
    print (data.shape)
    alldata = data # data.transpose((2,0,1))
  else:
    alldata = data.reshape([1]+[ i for i in data.shape])
  if not options.overlay_var is None:
    if options.overlay_file is None:
      (overlay_data, overlay_attrs, overlay_dimensions, overlay_pcm_dimensions, overlay_labels) = read_var (options.overlay_var, filename, options.overlay_level, options)
    else:
      (overlay_data, overlay_attrs, overlay_dimensions, overlay_pcm_dimensions, overlay_labels) = read_var (options.overlay_var, options.overlay_file, options.overlay_level, options)
    if (len(overlay_data.shape) == 3):
      overlay_slicecount = len(overlay_data)
      if overlay_slicecount != slicecount:
        fu.cerr("Overlay data has %d slices, normal data has %d slices -- How is that supposed to work?"%(overlay_slicecount, slicecount))
        sys.exit(666)
      print (overlay_data.shape)
    else:
      overlay_data = overlay_data.reshape([1]+[ i for i in overlay_data.shape])
      overlay_slicecount = 0
    if options.overlay_scale is not None:
      overlay_data = overlay_data * options.overlay_scale


  for (num, data) in enumerate(alldata):
    if options.scale is not None:
      data = data * options.scale
    if (options.figsize):
      mpl.figure(figsize=options.figsize)
    if (len(dimensions) >= 4  or any(maps)) : # 2d coordinates
      if options.MOLL:
        map = Basemap(resolution=options.resolution, projection='moll',\
                      lon_0=0, area_thresh=10000.)
        print ("MOLL")
      elif options.CYL:
        map = Basemap(resolution=options.resolution, projection='cyl',\
                      lon_0=0, area_thresh=10000.)
        print ("CYL")
      elif options.GL:
        map = Basemap(llcrnrlon=llcrnrlon,urcrnrlon=urcrnrlon,llcrnrlat=llcrnrlat,urcrnrlat=urcrnrlat,
                      resolution=options.resolution, projection='stere',\
                      lat_ts=71,lat_0=90,lon_0=-39.)
        print ("GL")
      elif options.NATL:
            map = Basemap(width=9500000,height=10000000, area_thresh=10000.,
                       resolution=options.resolution, projection='stere',\
                       lat_0=67,lon_0=-44.)
      elif options.PISM:
            map = Basemap(width=9500000,height=9500000,
                       resolution=options.resolution, projection='stere',\
                       lat_ts=71,lat_0=87,lon_0=-44.)
      elif options.diss_proj:
        print (llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat)
        map = Basemap(llcrnrlon=llcrnrlon,urcrnrlon=urcrnrlon,llcrnrlat=llcrnrlat,urcrnrlat=urcrnrlat,
                      resolution=options.resolution, projection='stere', area_thresh=10000., \
                      lat_0=90, lat_ts=71,lon_0=-44.)
      elif options.ANT:
        print ("ANT")
        print (llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat)
        map = Basemap(llcrnrlon=llcrnrlon,urcrnrlon=urcrnrlon,llcrnrlat=llcrnrlat,urcrnrlat=urcrnrlat,
                      resolution=options.resolution, projection='stere',\
                      lat_0=-90, lat_ts=-71,lon_0=180)
      else:
        print ("USING NSIDC POLAR STEREOGRAPHIC PROJECTION 90 -45 70")
        print (llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat)
        map = Basemap(llcrnrlon=llcrnrlon,urcrnrlon=urcrnrlon,llcrnrlat=llcrnrlat,urcrnrlat=urcrnrlat,
                      resolution=options.resolution, projection='stere', area_thresh=10000.,\
                      lat_0=90, lat_ts=70,lon_0=-45.)
      pcm_data=data
      if (len (dimensions[-1][:].shape) > 1 ):
        x, y = map(dimensions[-1][:], dimensions[-2][:])
        pcm_x, pcm_y = map(pcm_dimensions[-1][:], pcm_dimensions[-2][:])
      else:
#        if options.EN:
#           pcm_data, pcm_dimensions[-1] = addcyclic(pcm_data, pcm_dimensions[-1])
        x, y = map(*np.meshgrid(dimensions[-1][:], dimensions[-2][:]))
        pcm_x, pcm_y = map(*np.meshgrid(pcm_dimensions[-1][:], pcm_dimensions[-2][:]))


      pl = map
    else:
      pl = mpl
      x = dimensions[-2][:]
      y = dimensions[-1][:]
      pcm_x = x # actually needs to be shifted, too!
      pcm_y = y # actually needs to be shifted, too!
      if options.ocedepth:
        z = np.arange(len(y)+1)
        z[1:-1] = .5*(y[1:]+y[:-1])
        z[-1] = 1.5*y[-1]-.5*y[-2]
        pcm_y = z


    # DRAW IT
    mpl.gca().patch.set_color('.75')
    if options.missvalcolor:
      mpl.gca().patch.set_color(options.missvalcolor)
    if options.EN:
      pcm_data = pcm_data [:24]
      pcm_x = pcm_x[:25]
      pcm_y = pcm_y[:25]
    else:
      pcm_data = data
    if (( options.coast_first) and( (len(dimensions)  >= 4 or any (maps)))) : # 2d coordinates
      clc='.5'
      if options.whitecoast:
        clc = 'white'
      pl.drawcoastlines(linewidth=0.25, color=clc, zorder=-999)
      if options.rivers:
        pl.drawrivers(linewidth=0.25)
    if (not levels is None ):
      print (pcm_x.shape, pcm_y.shape, pcm_data.shape)
      if (not norm is None):
        pl.pcolormesh(pcm_x, pcm_y, pcm_data,  norm = norm ,  cmap=cmap )
      else:
        pl.pcolormesh(pcm_x, pcm_y, pcm_data,   cmap=cmap)
      mpl.colorbar()
      if not options.no_outline:
        pl.contour (x, y, pcm_data, levels,  colors="0.5", linewidths=.25, linestyles="solid")
    else:
      pl.pcolormesh(pcm_x, pcm_y, pcm_data,  cmap=cmap)
      mpl.colorbar()
      if not options.no_outline:
        pl.contour (x, y, data,  colors="0.5", linewidths=.25, linestyles="solid")
    if options.scaled:
      mpl.axis("scaled")

    if ((not options.coast_first) and( (len(dimensions)  >= 4 or any(maps)))) : # 2d coordinates
      clc='.5'
      if options.whitecoast:
        clc = 'white'
      pl.drawcoastlines(linewidth=0.25, color=clc)
    if (( (len(dimensions)  >= 4 or options.MOLL or options.CYL or options.GL or options.ANT or options.NATL or options.diss_proj or options.PISM or options.mapit))) : # 2d coordinates
      if options.rivers:
        pl.drawrivers(linewidth=0.25)
      pl.drawmeridians(np.arange(0,360,options.grid_spacing),linewidth=options.gridwidth, dashes=[10,1e-6],color=(.5,.5,.5))
      pl.drawparallels(np.arange(-90,90,options.grid_spacing),linewidth=options.gridwidth, dashes=[10,1e-6],color=(.5,.5,.5))

    # OVERLAY

    if not options.overlay_var is None:
      overlay_levels = sort_levels (options.overlay_levels)
      if (overlay_levels is not None):
        CS = pl.contour(x, y, overlay_data[min(num, overlay_slicecount)], overlay_levels, colors="k", linewidths=options.overlay_linewidths)
      else:
        CS = pl.contour(x, y, overlay_data[min(num, overlay_slicecount)], colors="k", linewidths=options.overlay_linewidths)
      if options.overlay_mark_gt:
        mpl.clabel(CS, fontsize=9, inline=1, use_clabeltext=True, rightside_up = False, fmt='A') # \u25BC for black triangles # u'\u2227'
      if options.overlay_clabel:
        mpl.clabel(CS, fontsize=9, inline=1, use_clabeltext=True, rightside_up = True, fmt=options.overlay_clabel_format)
      for line in CS.collections:
        if line.get_linestyle() != [(None, None)]:
          line.set_linestyle([(0, (12.0, 4.0))])
      if options.overlay_thick is not None:
        CS = pl.contour(x, y, overlay_data[min(num, overlay_slicecount)], (options.overlay_thick,), colors="k", linewidths=3.)
        for line in CS.collections:
          if line.get_linestyle() != [(None, None)]:
            line.set_linestyle([(0, (12.0, 4.0))])


    # MAKE IT NICE
    if "xlim" in options:
        mpl.xlim(options.xlim)
    if "ylim" in options:
      mpl.ylim(options.ylim)

    if options.xlabel is None:
      mpl.xlabel(labels[0])
    else:
      mpl.xlabel(options.xlabel)
    if options.ylabel is None:
      mpl.ylabel(labels[1])
    else:
      mpl.ylabel(options.ylabel)
    if options.title is None:
      if attrs.get("units", False):
        mpl.title("%s (%s)"%(attrs.get("long_name", var), attrs.get("units", "")))
      else:
        mpl.title("%s"%(attrs.get("long_name", var)))
    else:
      mpl.title(options.title)

    # SAVE TO FILE OR SHOW
    if not slices:
      if not options.outfile is  None:
        if options.outfile[-3:] == "png":
          mpl.savefig(options.outfile, dpi=200 )
          mpl.close('all')
        else:
          mpl.savefig(options.outfile)
          mpl.close('all')
      else:
        mpl.show()
        mpl.close('all')
    else:
      if not options.outfile is  None:
        lsc = math.ceil(math.log10(slicecount))
        if (lsc < 3):
          myout=re.sub(r'(.*)(\..*)', r'\1_%02d\2'%num, options.outfile)
        else:
          myout=re.sub(r'(.*)(\..*)', r'\1_%04d\2'%num, options.outfile)
        if options.outfile[-3:] == "png":
          mpl.savefig(myout, dpi=400 )
          mpl.close('all')
        else:
          mpl.savefig(myout)
          mpl.close('all')
      else:
        mpl.show()
        mpl.close('all')


def parse_args():
  '''Parses the command line arguments'''

  parser = ArgumentParser()
  parser.description = "Draw a contour plot"
  parser.add_argument("var")
  parser.add_argument("filename")

  parser.add_argument("-v", "--verbose",
    help='''Be verbose''', action="store_true")

  parser.add_argument("-o", "--outfile",
                      help='''output file to save image to''', default=None)
  parser.add_argument("--figsize",
                      help='''Size of image''', default=(10,8), type=float, nargs=2)

  parser.add_argument("-t", "--transpose",
    help='''transpose field (flip axis)''', action="store_true")
  parser.add_argument("--xlim",
    help='''set x limits (decreasing flips axis)''', nargs=2, type=float)
  parser.add_argument("--ylim",
    help='''set y limits (decreasing flips axis)''', nargs=2, type=float)
  parser.add_argument("--scaled",
                      help='''same scaling on both axes''', action="store_true")

  parser.add_argument("--no_outline",
                      help='''don't outline contour levels''', action="store_true")

  parser.add_argument("--ll",
    help='''lat lon of lower left corner NEEDS --ur''', nargs=2, type=float)
  parser.add_argument("--ur",
    help='''lat lon of upper right corner NEEDS --ll''', nargs=2, type=float)
  parser.add_argument("-M", "--MOLL",
                      help='''Adjust map for Mollweide plot''', action="store_true")
  parser.add_argument("-C", "--CYL",
                      help='''Adjust map for Cylindrical plot''', action="store_true")
  parser.add_argument("-G", "--GL",
                      help='''Adjust map for Greenland plot''', action="store_true")
  parser.add_argument("-N", "--NATL",
                      help='''Adjust map for NATL plot''', action="store_true")
  parser.add_argument("-P", "--PISM",
                      help='''Adjust map for PISM plot''', action="store_true")
  parser.add_argument("-A", "--ANT",
                      help='''Adjust map for ANT plot''', action="store_true")
  parser.add_argument( "--diss_proj",
                      help='''Adjust map for diss projection plot''', action="store_true")
  parser.add_argument("--mapit",
                      help='''Definitely do map plot''', action="store_true")
  parser.add_argument("-l", "--level",
                      help='''which level to plot (for multi-level vars)''', type=int, default = None)
  parser.add_argument("--lat",
                      help='''use lat as axis in sections with lon or lat avail''', action="store_true")
  parser.add_argument("--lon",
                      help='''use lon as axis in sections with lon or lat avail''', action="store_true")
  parser.add_argument("--rotlon",
                      help='''Move lon values from 0..360 to -180..180''', action="store_true")

  parser.add_argument("--EN",
                      help='''ECHAM NORTHERN HEMISPHERE PLOT''', action="store_true")
  parser.add_argument("--EG",
                      help='''ECHAM Global plot''', action="store_true")
  parser.add_argument("--ocedepth",
                      help='''Estimate ocean depth levels in pcolormesh''', action="store_true")

  parser.add_argument("--scale",
                      help='''scale data by''', type=float, default = None)
  parser.add_argument("--overlay_scale",
                      help='''scale overlay data by''', type=float, default = None)
  parser.add_argument("--overlay_level",
                      help='''which level to plot (for multi-level vars)''', type=int, default = None)

  parser.add_argument("-m", "--minmax",
                      help='''set minimum and maximum for contours''', nargs=2, type=float, default = None)
  parser.add_argument("--levels",
                      help='''set levels for plotting. n = n levels, 1,2,3 = draw levels at 1, 2, and 3''')
  parser.add_argument("--whitecoast",
                      help='''Draw white coastlines''', action="store_true")
  parser.add_argument("--coast_first",
                      help='''Draw coastlines before contour plot''', action="store_true")
  parser.add_argument("--rivers",
                      help='''Draw rivers''', action="store_true")
  parser.add_argument("--resolution",
                      help='''Resolution of map features [clihf]''', default="l")
  parser.add_argument("--gridwidth",
                      help='''Width of gridlines''', type=float , default=0.25)
  parser.add_argument("--grid_spacing",
                      help='''Spacing of gridlines''', type=float , default=10)

  parser.add_argument("-T", "--title",
                      help='''plot title''', default=None)
  parser.add_argument("--xlabel",
                      help='''x axis label''', default=None)
  parser.add_argument("--ylabel",
                      help='''y axis label''', default=None)
  parser.add_argument("-c", "--cmap",
    help='''Name of a colormap''')
  parser.add_argument("--font_scale",
                    help='''scale fontsize by factor ''', type=float , default=1.)

  parser.add_argument("-s", "--sub", default=None)
  parser.add_argument("--missval", type = float, default = None)
  parser.add_argument("--missvalcolor", default = None)

  parser.add_argument("--overlay_var", default=None)
  parser.add_argument("--overlay_file", default=None)
  parser.add_argument("--overlay_levels", default=None,
    help='''set levels for plotting. n = n levels, 1,2,3 = draw levels at 1, 2, and 3''')
  parser.add_argument("--overlay_linewidths", default=1.5, type=float,
    help='''Thickness of overlay lines''')
  parser.add_argument("--overlay_thick", default=None, type=float,
    help='''set level for thick line in overlay''')
  parser.add_argument("--overlay_clabel", action="store_true",
    help='''add labels to overlay contours''')
  parser.add_argument("--overlay_clabel_format", default="%f",
    help='''format for overlay contour labels''')
  parser.add_argument("--overlay_mark_gt", action="store_true",
    help='''add > signs to overlay contours to mark directions''')


  options = parser.parse_args()
  return options


def main():
  '''Analyze the run. Call all that's needed.'''
  options = parse_args()
  sns.set(style=sns.axes_style(), font_scale=options.font_scale)
  contour_var(options.var, options.filename, options)

if __name__ == "__main__":
  main()
