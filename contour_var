#!/usr/bin/env python
from __future__ import print_function


from netCDF4 import Dataset as nc
import numpy as np
import matplotlib.pylab as mpl
# import flo_utils as fu

from argparse import ArgumentParser
# import json
# import os
# import shlex
# import shutil
# import subprocess
import sys

try:
  import seaborn as sns
  seaborn = True
except ImportError:
  seaborn = False



def contour_var(var, filename, options):
  f = nc(filename)
  vars = f.variables
  var = vars[var]
  if type(var[:]) is np.ma.masked_array:
    m = np.ma.masked_array(np.squeeze(var),np.squeeze(var[:].mask))
  else :
    m = np.squeeze(var)
  dims = var.dimensions
  sizes = var.shape

  rd = [vars.get(x,np.arange(sizes[n])) for n,x in enumerate(dims) if sizes[n] > 1 ]
  offset=-1
  labels = ["", ""]
  for n,x in enumerate (dims):
    if sizes[n] > 1:
      offset += 1
      labels[offset] = dims[n]
      if not x  in vars.keys():
        print ("Trying to substitute %s"%(x))
        if ("lat" in vars.keys() and "lon" in vars.keys() and (vars["lat"].size > 1 or vars ["lon"].size > 1)):
          print ("Found coordinate variables")
          la = np.squeeze(vars["lat"])
          lo = np.squeeze(vars["lon"])
          print (lo.shape)
          if la.shape == lo.shape == (sizes[n],):
            print ("Sizes match")
            lad = la[-1]-la[0]
            lod = lo[-1]-lo[0]
            if (abs(lad) > abs (lod)):
              rd[offset]=la
              labels[offset] = "lat"
            else:
              rd[offset]=lo
              labels[offset] = "lon"

  if options.transpose: # python has a very strange understanding of order -- we'll fix that
    rd=rd[::-1]
  else:
    m=m.transpose()
  fig = mpl.figure()
  cmap = None
#  cmap = sns.color_palette(options.cmap, options.levels if options.levels and len(options.levels.split(",")) == 1 else 7, as_cmap=True)
  levels = options.levels[0] if options.levels else None
  try:
    if (options.cmap):
      cmap=options.cmap
    else:
      cmap = sns.cubehelix_palette(as_cmap=True, start=.5)
  except:
    print ("Trouble using colorbar %s with %s levels"%(options.cmap, levels if levels else "None"), file=sys.stderr)
  if not levels is None:
    levels = [float(x) for x in options.levels.split(',')]
#    levels = [m.min()] + levels + [m.max()]
    if (len(levels) == 1 ):
      levels = int(levels[0])
  else:
    levels = None
  if (levels):
    mpl.contourf(rd[0][:], rd[1][:], m, levels, cmap=cmap)
  else:
    mpl.contourf(rd[0][:], rd[1][:], m, cmap=cmap)
  if "xlim" in options:
      mpl.xlim(options.xlim)
  if "ylim" in options:
    mpl.ylim(options.ylim)
  mpl.xlabel(labels[0])
  mpl.ylabel(labels[1])

  mpl.colorbar()
  mpl.show()



def parse_args():
  '''Parses the command line arguments'''

  parser = ArgumentParser()
  parser.description = "Draw a contour plot"
  parser.add_argument("var")
  parser.add_argument("filename")
  parser.add_argument("-v", "--verbose",
    help='''Be verbose''', action="store_true")
  # parser.add_argument("-o", "--output_dir",
  #     help='''output directory to save images to''', default=None)
  # parser.add_argument("-r", "--reference",
  #     help='''reference run''', default=None)
  # parser.add_argument("-a", "--TSA",
  #     help='''Add time series for runs''', default=None)
  parser.add_argument("--xlim",
    help='''set x limits (decreasing flips axis)''', nargs=2, type=float)
  parser.add_argument("--ylim",
    help='''set y limits (decreasing flips axis)''', nargs=2, type=float)
  parser.add_argument("--levels",
    help='''set levels for plotting. n = n levels, 1,2,3 = draw levels at 1, 2, and 3''')
  parser.add_argument("-t", "--transpose",
    help='''transpose field (flip axis)''', action="store_true")
  # parser.add_argument("-t", "--title",
  #     help='''plot title''', default=None)
  parser.add_argument("-c", "--cmap",
    help='''Name of a colormap''')

  options = parser.parse_args()
  return options


def main():
  '''Analyze the run. Call all that's needed.'''
  options = parse_args()
  contour_var(options.var, options.filename, options)

if __name__ == "__main__":
  main()
